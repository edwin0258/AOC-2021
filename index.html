<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="author" content="Devin Miller">
        <link rel="icon" href="https://styles.redditmedia.com/t5_2fwo/styles/communityIcon_1bqa1ibfp8q11.png?width=256&s=45361614cdf4a306d5510b414d18c02603c7dd3c">
        <link rel="stylesheet" type="text/css" href="index.css"/>
        <link rel="stylesheet" type="text/css" href="desert.css"/>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/devicon.min.css">
        <title>AOC-2021 solutions</title>
    </head>
,<body>
        <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
        <h1 id='page-top' class="page-header">AOC-2021 Solutions ~ Devin Miller</h1>
        <h2>Days Completed</h2>
        <a class='to-page-top' href='#page-top'>Back to Top</a>
        
,<div class='day-links'><a class='day-link' href='#day1'>day1</a><a class='day-link' href='#day2'>day2</a><a class='day-link' href='#day3'>day3</a><a class='day-link' href='#day4'>day4</a><a class='day-link' href='#day5'>day5</a><a class='day-link' href='#day6'>day6</a><a class='day-link' href='#day7'>day7</a><a class='day-link' href='#day8'>day8</a><a class='day-link' href='#day9'>day9</a></div><h2 class='day-header' id='day1'>day1<img class='lang-icon' src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/javascript/javascript-original.svg" /><img class='lang-icon' src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg" /></h2><div class='codes'><div class='code'><h3 class='code-header'>sonarSweep.js</h3><pre class='prettyprint'><code>const fs = require('fs')


fs.readFile('sonarSweep.txt', (err, data) => {
    if (err) throw err;

    const lines = data.toString().split('\n');
    let [numGreater, prev] = [0, 0];

    lines.forEach(l => {
        numGreater += (prev < +l) ? 1 : 0;
        prev = +l;
    }) 

    console.log(numGreater - 1)
})
</code></pre></div><div class='code'><h3 class='code-header'>sonarSweep.py</h3><pre class='prettyprint'><code>f = open('sonarSweep.txt', 'r')

[count, prev] = [0, 0]

for line in f:
    if prev < int(line):
        count += 1
    prev = int(line)

print(count - 1) # don't count first increase
</code></pre></div><div class='code'><h3 class='code-header'>sonarSweep2.js</h3><pre class='prettyprint'><code>const fs = require('fs')

fs.readFile('sonarSweep.txt', (err, data) => {
    if (err) throw err;

    let [numGreater, prev, windowSize] = [0, 0, 3];

    const lines = data.toString().split('\n').map(x => parseInt(x));

    // Windowing lines
    let winLines = lines.map((x, i, arr) => {
        if(i + 2 <= arr.length)
            return arr.slice(i, i + windowSize).reduce((total, x) => total + x)
        return Infinity
    })

    winLines.forEach(l => {
        numGreater += (prev < l) ? 1 : 0;
        prev = l;
    }) 

    console.log(numGreater - 1)
})
</code></pre></div><div class='code'><h3 class='code-header'>sonarSweep2.py</h3><pre class='prettyprint'><code>f = open('sonarSweep.txt', 'r')

[count, prev, windowSize] = [0, 0, 3]

dataArr = [int(line) for line in f]

for i, x in enumerate(dataArr):
    curr = sum(dataArr[i:i+windowSize])
    if prev < curr:
        count += 1 
    prev = curr 
    
print(count - 1) # don't count first increase
</code></pre></div></div><h2 class='day-header' id='day2'>day2<img class='lang-icon' src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/javascript/javascript-original.svg" /><img class='lang-icon' src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg" /></h2><div class='codes'><div class='code'><h3 class='code-header'>sub.js</h3><pre class='prettyprint'><code>const fs = require('fs');

fs.readFile('data.txt', (err, data) => {
    if (err) throw err;

    let lines = data.toString().split('\n').map(x => x.split(' '));
    let [hor, vert] = [0, 0];

    lines.forEach(l => {
        let [dir, a] = [l[0], parseInt(l[1])]
        let funcs = {'forward': (() => hor += a), 
                     'down':    (() => vert += a), 
                     'up':      (() => vert -=a)}
        if(dir in funcs)
            funcs[dir]();
    })

    console.log(hor * vert);
})
</code></pre></div><div class='code'><h3 class='code-header'>sub.py</h3><pre class='prettyprint'><code>f = open('data.txt', 'r')

[hor, vert] = [0, 0]
for x in f:
    [d, i] = x.split(' ')
    if d == "forward":
        hor += int(i)
    elif d == "down":
        vert += int(i)
    elif d == "up":
        vert -= int(i)

print("HOR", hor)
print("VERT", vert)

print(hor * vert)
</code></pre></div><div class='code'><h3 class='code-header'>sub2.js</h3><pre class='prettyprint'><code>const fs = require('fs');

fs.readFile('data.txt', (err, data) => {
    if (err) throw err;

    let lines = data.toString().split('\n').map(x => x.split(' '));
    let [hor, vert, aim] = [0, 0, 0];

    lines.forEach(l => {
        let [dir, amount] = [l[0], parseInt(l[1])]
        let funcs = {'forward': (() => {
                                    hor += amount;
                                    vert += (aim * amount);
                                }), 
                     'down':    (() => aim += amount), 
                     'up':      (() => aim -= amount)}

        if(dir in funcs)
            funcs[dir]();
    })

    console.log(hor * vert);
})
</code></pre></div><div class='code'><h3 class='code-header'>sub2.py</h3><pre class='prettyprint'><code>f = open('data.txt', 'r')

[hor, vert, aim] = [0, 0, 0]
for x in f:
    [d, i] = x.split(' ')
    if d == "forward":
        hor += int(i)
        vert += aim * int(i)
    elif d == "down":
        aim += int(i)
    elif d == "up":
        aim -= int(i)

print("HOR", hor)
print("VERT", vert)

print(hor * vert)
</code></pre></div></div><h2 class='day-header' id='day3'>day3<img class='lang-icon' src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/javascript/javascript-original.svg" /><img class='lang-icon' src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg" /></h2><div class='codes'><div class='code'><h3 class='code-header'>day3-1.js</h3><pre class='prettyprint'><code>const fs = require('fs');

fs.readFile('data.txt', (err, data) => {
    if (err) throw err;

    let lines = data.toString().split('\n').map(x => x.split(''));
    // we are looking at columns, not rows in this challenge.
    let linesTransposed = lines[0].map((_, colIndex) => lines.map(row => row[colIndex]));
    let [gamma, epsilon] = ['', '']; 
    
    linesTransposed.forEach(col => {
        let [ones, zeros] = [0, 0];

        // count number of 1's and 0's in col
        col.forEach(x => {
            if(x == '1') ones += 1
            else if(x == '0') zeros += 1
        })
        
        // gamma = 1 if more 1's and 0 if more 0's. Epsilon is opposite.
        gamma += Number(ones > zeros);
        epsilon += Number(zeros > ones);
    })

    // log solution 
    console.log(parseInt(gamma, 2) * parseInt(epsilon, 2));
})
</code></pre></div><div class='code'><h3 class='code-header'>day3-2.js</h3><pre class='prettyprint'><code>const fs = require('fs');


function filterBinaries(lines, func) {
    let linesTemp = lines; // temp used for filtering for each col solution
    let i = 0;

    while(linesTemp.length > 1) {
        let [ones, zeros] = [0, 0];

        // count number of 1's and 0's in certain col
        for(let row = 0; row < linesTemp.length; row++) {
            if(linesTemp[row][i] == '1') ones += 1
            else if(linesTemp[row][i] == '0') zeros += 1
        }
        
        // pass lines temp into specific filter function
        linesTemp = func(ones, zeros, linesTemp, i);
        i++;
    }

    return linesTemp[0].join('');
}

let getOxyGen = ((ones, zeros, linesTemp, i) => {
    if(ones >= zeros)
        return linesTemp.filter(x => x[i] == '1');
    return linesTemp.filter(x => x[i] == '0');
})

let getCo2 = ((ones, zeros, linesTemp, i) => {
    if(ones < zeros)
        return linesTemp.filter(x => x[i] == '1');
    return linesTemp.filter(x => x[i] == '0');
})

fs.readFile('data.txt', (err, data) => {
    if (err) throw err;

    let l = data.toString().split('\n').map(x => x.split(''));
    let [lifeSupport, oxygenGen, co2] = [0, filterBinaries(l, getOxyGen), filterBinaries(l, getCo2)]; 

    lifeSupport = parseInt(oxygenGen, 2) * parseInt(co2, 2);

    // log solution
    console.log(lifeSupport);
})
</code></pre></div><div class='code'><h3 class='code-header'>day3a.py</h3><pre class='prettyprint'><code>data = open("data.txt", "r").read().splitlines()

def getMC(n):
    col = ""
    for row in data:
        col += row[n]

    ones = col.count('1')
    zeros = col.count('0')
    return int(ones > zeros) #return 1 or 0 for most common num

mcs = [getMC(n) for n in range(len(data[0]))] # most common in each col
lcs = [1 - n for n in mcs] # least common in each col

# convert to base 10, store in variables
gammaRate = int(''.join(map(str, mcs)), 2)
epsilonRate = int(''.join(map(str, lcs)), 2)

print(gammaRate, epsilonRate)
print(gammaRate * epsilonRate)
</code></pre></div></div><h2 class='day-header' id='day4'>day4<img class='lang-icon' src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/javascript/javascript-original.svg" /></h2><div class='codes'><div class='code'><h3 class='code-header'>day4-1.js</h3><pre class='prettyprint'><code>const fs = require('fs');

fs.readFile('data.txt', (err, data) => {
    if (err) throw err;

    let boardSize = 5; // five rows per board

    let [nums, ...boards] = data.toString().split('\n')
    nums = nums.split(',');
    boards = boards.filter(x => x.length > 4); // filter out empty lines
    let boardsSplit = []; // 2d array with 1st level representing each board
    let boardStats = []; // hold how many marked in x and y 

    for(let i = 0; i < boards.length; i+=boardSize) {
        boardsSplit.push(boards.slice(i, i+boardSize)); // one board per index
        boardStats.push({'x': Array(boardSize).fill(0), 'y': Array(boardSize).fill(0)})
    }
    
    boardsSplit = boardsSplit.map(board => board.join(' ').split(' ').filter(x => x.length != 0));
    callBingoNums(nums, boardsSplit, boardStats, boardSize); 
})


function callBingoNums(bns, boards, stats, size) {
    let calledNums = [];
    bns.some(num => { // some used so can break out once winner determined
        calledNums.push(num); // record number being called
        // record num being found in board stats if found
        boards.forEach((b, bi) => {
            let matches = b.filter(bnum => bnum == num);
            if(matches.length > 0) {
                let y = b.indexOf(matches[0]) % size; // col of match
                let x = Math.floor(b.indexOf(matches[0]) / size);

                stats[bi]['x'][x] += 1;
                stats[bi]['y'][y] += 1;
            }
        })

        let check = checkStats(stats);
        if(check[0] != -1) {
            console.log("WINNER BOARD: " + (check[0]+1)); 
            printSolution(boards[check[0]], calledNums);
            return true; // we are done
        }
    })
}

// check to see if there is a bingo winner
// returns: [winner? (-1, board index), (0: row, 1: col), row/col index]
function checkStats(stats) {
    let check = [-1, -1, -1];
    stats.forEach((bstats, bi) => {
        if(bstats['x'].indexOf(5) != -1) {
            check = [bi, 0, bstats['x'].indexOf(5)];
        } else if(bstats['y'].indexOf(5) != -1) {
            check = [bi, 1, bstats['y'].indexOf(5)];
        }
    })

    return check;
}

// calculate and print solution to challenge
function printSolution(board, calledNums) {
    let sum = board.filter(x => calledNums.indexOf(x) == -1)
               .reduce((sum, x) => sum + parseInt(x), 0);
    console.log(sum * calledNums[calledNums.length - 1]);
}
</code></pre></div><div class='code'><h3 class='code-header'>day4-2.js</h3><pre class='prettyprint'><code>const fs = require('fs');

fs.readFile('data.txt', (err, data) => {
    if (err) throw err;

    let boardSize = 5; // five rows per board

    let [nums, ...boards] = data.toString().split('\n')
    nums = nums.split(',');
    boards = boards.filter(x => x.length > 4); // filter out empty lines
    let boardsSplit = []; // 2d array with 1st level representing each board
    let boardStats = []; // hold how many marked in x and y 

    for(let i = 0; i < boards.length; i+=boardSize) {
        boardsSplit.push(boards.slice(i, i+boardSize)); // one board per index
        boardStats.push({'x': Array(boardSize).fill(0), 'y': Array(boardSize).fill(0)})
    }
    
    boardsSplit = boardsSplit.map(board => board.join(' ').split(' ').filter(x => x.length != 0));
    callBingoNums(nums, boardsSplit, boardStats, boardSize); 
})


function callBingoNums(bns, boards, stats, size) {
    let calledNums = [];
    let winnerOrder = [];
    bns.some(num => { // some used so can break out once winner determined
        calledNums.push(num); // record number being called
        // record num being found in board stats if found
        boards.forEach((b, bi) => {
            let matches = b.filter(bnum => bnum == num);
            if(matches.length > 0) {
                let y = b.indexOf(matches[0]) % size; // col of match
                let x = Math.floor(b.indexOf(matches[0]) / size);

                stats[bi]['x'][x] += 1;
                stats[bi]['y'][y] += 1;
            }
        })

        let check = checkStats(stats, winnerOrder);
        winnerOrder = check[3];
        if(check[0] != -1) {
            console.log("WINNER BOARD: " + (check[0]+1)); 
            printSolution(boards[check[0]], calledNums);
            return true; // we are done
        }
    })
}

// check to see if there is a bingo winner
// returns: [winner? (-1, board index), (0: row, 1: col), row/col index, winnerOrder]
// only return successful check for last winner (part 2)
function checkStats(stats, winnerOrder) {
    let check = [-1, -1, -1];
    stats.forEach((bstats, bi) => {
        if(bstats['x'].indexOf(5) != -1) {
            if(winnerOrder.indexOf(bi) == -1) {
                winnerOrder.push(bi);
                if(winnerOrder.length == stats.length)
                    check = [bi, 0, bstats['x'].indexOf(5)];
            }
        } else if(bstats['y'].indexOf(5) != -1) {
            // only add to order if not already a winner
            if(winnerOrder.indexOf(bi) == -1) {
                winnerOrder.push(bi);
                // only last winner check is returned
                if(winnerOrder.length == stats.length)
                    check = [bi, 1, bstats['y'].indexOf(5)];
            }
        }
    })

    check.push(winnerOrder);
    return check;
}

// calculate and print solution to challenge
function printSolution(board, calledNums) {
    let sum = board.filter(x => calledNums.indexOf(x) == -1)
               .reduce((sum, x) => sum + parseInt(x), 0);
    console.log(sum * calledNums[calledNums.length - 1]);
}
</code></pre></div></div><h2 class='day-header' id='day5'>day5<img class='lang-icon' src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg" /></h2><div class='codes'><div class='code'><h3 class='code-header'>day5-1.py</h3><pre class='prettyprint'><code>f = open('data.txt', 'r')

coords = [] # keep track of coords with atleast 1 vent

def storeRange(rg, const, d, coords): # (range, constant num, dir, coords)
    for c in rg:
        coord = (str(c) + ',' + str(const)) if (d == 0) else (str(const) + ',' + str(c))
        coords.append(coord)

def calculateSolution(coords):
    coordOcs = {} # count how many times (occurences) a coord appears
    count = 0 # for counting coords with 2 or more ocs

    for c in coords:
        if c in coordOcs:
            coordOcs[c] += 1
        else:
            coordOcs[c] = 1

    for c in coordOcs:
        if coordOcs[c] > 1:
            count += 1
    
    print(count)

for l in f:
    [c1, c2] = l.split('->')
    [c1, c2] = [list(map(int, c1.split(','))), list(map(int, c2.split(',')))]
    #print(int(c1[0]), int(c2[0]))

    if(c1[0] != c2[0] and c1[1] != c2[1]):
        continue # ignore diag for now

    # hor or vert
    elif(c1[0] != c2[0]):
        if(c1[0] < c2[0]):
            storeRange(range(c1[0], c2[0]+1), c1[1], 0, coords)
        else:
            storeRange(range(c2[0], c1[0]+1), c1[1], 0, coords)
        
    elif(c1[1] != c2[1]):
        if(c1[1] < c2[1]):
            storeRange(range(c1[1], c2[1]+1), c1[0], 1, coords)
        else:
            storeRange(range(c2[1], c1[1]+1), c1[0], 1, coords)


calculateSolution(coords)
</code></pre></div><div class='code'><h3 class='code-header'>day5-2.py</h3><pre class='prettyprint'><code>f = open('data.txt', 'r')

coords = [] # keep track of coords with atleast 1 vent

def storeRange(rg, const, d, coords, v=0): # (range, constant num, dir, coords, up/down (diag))
    for c in rg:
        coord = (str(c) + ',' + str(const)) if (d == 0 or d == 2) else (str(const) + ',' + str(c))
        coords.append(coord)

        if(v == 1): # down
            const += 1
        elif(v == 2):
            const -= 1

def calculateSolution(coords):
    coordOcs = {} # count how many times (occurences) a coord appears
    count = 0 # for counting coords with 2 or more ocs

    for c in coords:
        if c in coordOcs:
            coordOcs[c] += 1
        else:
            coordOcs[c] = 1

    for c in coordOcs:
        if coordOcs[c] > 1:
            count += 1
    
    print(count)

for l in f:
    [c1, c2] = l.split('->')
    [c1, c2] = [list(map(int, c1.split(','))), list(map(int, c2.split(',')))]

    if(c1[0] != c2[0] and c1[1] != c2[1]):
        # diag down or up
        if(c1[0] < c2[0]):
            r = range(c1[0], c2[0]+1)
            yStart = c1[1]
            if (c1[1] < c2[1]):# down
                v = 1
            else: # up
                v = 2
        else:
            r = range(c2[0], c1[0]+1)
            yStart = c2[1]
            v = 1 if(c2[1] < c1[1]) else 2

        storeRange(r, yStart, 2, coords, v) # const will change in this case

    # hor or vert
    elif(c1[0] != c2[0]):
        [x1, x2] = sorted([c1[0], c2[0]]) # smallest first
        storeRange(range(x1, x2+1), c1[1], 0, coords)
        
    elif(c1[1] != c2[1]):
        [y1, y2] = sorted([c1[1], c2[1]])
        storeRange(range(y1, y2+1), c1[0], 1, coords)


calculateSolution(coords)
</code></pre></div></div><h2 class='day-header' id='day6'>day6<img class='lang-icon' src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg" /></h2><div class='codes'><div class='code'><h3 class='code-header'>day6-1.py</h3><pre class='prettyprint'><code>fish = open('data.txt', 'r').readline().strip().split(',')
fish = list(map(int, fish))

days = 80 # how many days to run simulation
newFish = [] # new fish to be added to fish after they grow up 

for d in range(0, days):
    fish = [f - 1 if f > 0 else 6 for f in fish]
    fish = fish + [2] * newFish.count(3)
    newFish = [f - 1 for f in newFish if f != 3]
    newFish = newFish + [8] * fish.count(6)

print(len(fish) + len(newFish))

</code></pre></div><div class='code'><h3 class='code-header'>day6-2.py</h3><pre class='prettyprint'><code>f = open('data.txt', 'r').readline().strip().split(',')
f = list(map(int, f))
fish = {}
newFish = {} # new fish to be added to fish after they grow up 
adultCycle = 6
babyCycle = 8
days = 256

# count fish in groups to reduce calculation time
for x in range(0, adultCycle+1):
    fish[x] = 0
for x in range(adultCycle-1, babyCycle+1):
    newFish[x] = 0

for fi in f:
    fish[fi] += 1

def rotateLeft(d): # rotate values to left in dict, left most is put on right 
    tempDict = {}
    for k in d:
        nextK = k+1
        if(nextK in d):
            tempDict[k] = d[nextK]
        else:
            tempDict[k] = d[next(iter(d))]
    return tempDict 

def sumKeys(d):
    t = 0
    for k in d:
        t += d[k]
    return t

for d in range(0, days):
    fish = rotateLeft(fish)
    newFish = rotateLeft(newFish)
    fish[adultCycle-2] += newFish[babyCycle] # any new fish that has max num key is not new (becomes adult)
    newFish[babyCycle] = 0 # remove new fish with max key, no longer new
    newFish[babyCycle] = fish[adultCycle] # any fish with a max adult key creates a new fish
    
print(sumKeys(fish) + sumKeys(newFish))
</code></pre></div></div><h2 class='day-header' id='day7'>day7<img class='lang-icon' src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/javascript/javascript-original.svg" /></h2><div class='codes'><div class='code'><h3 class='code-header'>day7-1.js</h3><pre class='prettyprint'><code>const fs = require('fs');

fs.readFile('data.txt', (err, data) => {
    if (err) throw err

    let positions = {}; // store positions in groups
    let maxPos = 0;
    let minFuel = Infinity;
    
    data.toString().split('\n')[0].split(',').map(x => +x).forEach(pos => {
        maxPos = (pos > maxPos) ? pos : maxPos; // used for for loop later
        (pos in positions) ? positions[pos] += 1 : positions[pos] = 1;
    })

    // test how much fuel all crabs need to reach each i pos 
    for(let i = 0; i <= maxPos; i++) {
        let fuelNeeded = 0;
        Object.keys(positions).forEach(pos => {
            let distBetween = (pos > i) ? (pos - i) : (i - pos);
            fuelNeeded += (distBetween * positions[pos]); // dist * all crabs at pos
        })
        // Does pos offer min fuel required or not
        if(minFuel > fuelNeeded) minFuel = fuelNeeded;
    }

    console.log(minFuel);
})
</code></pre></div><div class='code'><h3 class='code-header'>day7-2.js</h3><pre class='prettyprint'><code>const fs = require('fs');

fs.readFile('data.txt', (err, data) => {
    if (err) throw err

    let positions = {}; // store positions in groups
    let maxPos = 0;
    let minFuel = Infinity;
    
    data.toString().split('\n')[0].split(',').map(x => +x).forEach(pos => {
        maxPos = (pos > maxPos) ? pos : maxPos; // used for for loop later
        (pos in positions) ? positions[pos] += 1 : positions[pos] = 1;
    })

    // test how much fuel all crabs need to reach each i pos 
    for(let i = 0; i <= maxPos; i++) {
        let fuelNeeded = 0;
        Object.keys(positions).forEach(pos => {
            let distBetween = (pos > i) ? (pos - i) : (i - pos);
            // calculate nth triangle number (part 2)
            // https://www.mathsisfun.com/algebra/triangular-numbers.html
            let trangularNum = distBetween * ((distBetween+1)/2);
            fuelNeeded += (trangularNum * positions[pos]); // dist * all crabs at pos
        })
        // Does pos offer min fuel required or not
        if(minFuel > fuelNeeded) minFuel = fuelNeeded;
    }

    console.log(minFuel);
})
</code></pre></div></div><h2 class='day-header' id='day8'>day8<img class='lang-icon' src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/javascript/javascript-original.svg" /></h2><div class='codes'><div class='code'><h3 class='code-header'>day8-1.js</h3><pre class='prettyprint'><code>const fs = require('fs');

fs.readFile('data.txt', (err, data) => {
    if (err) throw err

    let lines = data.toString().split('\n');
    let totalDigitCount = 0;

    lines.forEach(line => {
        let lineDigitCount = 0;

        if(line.length > 0) {
            let [patterns, output] = line.split('|');
            patterns = patterns.split(' ').filter(x => x.length > 0);
            output = output.split(' ').filter(x => x.length > 0);

            output.forEach(out => {
                if([2,3,4,7].includes(out.length)) {
                    lineDigitCount += 1;
                }
            })
        }

        totalDigitCount += lineDigitCount;
    })

    console.log(totalDigitCount);
})
</code></pre></div><div class='code'><h3 class='code-header'>day8-2.js</h3><pre class='prettyprint'><code>const fs = require('fs');

// len sort function
let sortFuncLen = arr => arr.sort((a, b) => a.length - b.length);
// character sort
let sortFunc = arr => arr.sort((a, b) => a > b);

function determineNums(patterns) {
    let nums = {0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: []}
    // translation of random pattern to normal display chars used (to be used later)
    let display = {'a': '', 'b': '', 'c': '', 'd': '', 'e': '', 'f': '', 'g': ''}
    patterns = sortFuncLen(patterns); // sort for simplier algo

    nums[1] = patterns[0].split('');
    nums[4] = patterns[2].split('');
    nums[7] = patterns[1].split('');
    nums[8] = patterns[9].split('');

    patterns.forEach(pattern => {
        if(nums[4].filter(x => pattern.includes(x)).length == 3 &&
           nums[1].filter(x => pattern.includes(x)).length == 2) {
            // determine 3 and 0
            if(pattern.length == 5) nums[3] = pattern.split('');
            else if(pattern.length == 6) nums[0] = pattern.split('');
        } else if(pattern.length == 5) {
            // 5 and 2
            if(nums[4].filter(x => pattern.includes(x)).length == 3)
                nums[5] = pattern.split('');
            else
                nums[2] = pattern.split('');
        } else if(pattern.length == 6) {
            // 6 and 9
            if(nums[4].filter(x => pattern.includes(x)).length == 4)
                nums[9] = pattern.split('');
            else
                nums[6] = pattern.split('');
        }
    })

    return nums
}

fs.readFile('data.txt', (err, data) => {
    if (err) throw err

    let lines = data.toString().split('\n');
    let totalOutput = 0;

    lines.forEach(line => {
        let lineDigitCount = 0;
        let decoded = ''; // decoded numbers

        if(line.length > 0) {
            let [patterns, output] = line.split('|');
            patterns = patterns.split(' ').filter(x => x.length > 0);
            output = output.split(' ').filter(x => x.length > 0);

            let nums = determineNums(patterns);

            // sort each and join for easier comparing against output
            Object.keys(nums).forEach(n => nums[n] = sortFunc(nums[n]).join(''));
            output = output.map(o => sortFunc(o.split('')).join(''));

            output.forEach(o => {
                for(n in nums) {
                    if(nums[n] == o) decoded += n;
                }
            })

            totalOutput += parseInt(decoded);
        }
    })


    console.log(totalOutput);
})
</code></pre></div></div><h2 class='day-header' id='day9'>day9<img class='lang-icon' src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg" /></h2><div class='codes'><div class='code'><h3 class='code-header'>day9-1.py</h3><pre class='prettyprint'><code>data = open('data.txt', 'r')

def formatData(data):
    output = []
    for line in data:
        # split into indv nums, convert all to int. Make sure appending a list
        lineHeights = list(line.strip())
        lineHeights = map(int, lineHeights)
        output.append(list(lineHeights))
    return output 

def determineLows(hts): # heights = hts
    lows = []
    for y, col in enumerate(hts):
        for x, h in enumerate(col):
            # val can't be greater than 9 so this is default
            [up, down, left, right] = [10,10,10,10] 

            # get adjacent heights 
            if(y != 0):
                up = hts[y-1][x]
            if(y != len(hts) - 1):
                down = hts[y+1][x]
            if(x != 0):
                left = hts[y][x-1]
            if(x != len(col) - 1):
                right = hts[y][x+1]

            # low flag
            isLow = True

            # test if height is lower than all directions or not
            for d in [up, down, left, right]:
                if (h >= d):
                   isLow = False 

            if(isLow):
                lows.append(h)
    return lows

heights = formatData(data) 
lows = determineLows(heights)

# print solution
print(sum(list(map(lambda x: x + 1, lows))))
</code></pre></div><div class='code'><h3 class='code-header'>day9-2.py</h3><pre class='prettyprint'><code>data = open('data.txt', 'r')

def formatData(data):
    output = []
    for line in data:
        # split into indv nums, convert all to int. Make sure appending a list
        lineHeights = list(line.strip())
        lineHeights = map(int, lineHeights)
        output.append(list(lineHeights))

    return output 


def determineLows(hts): # heights = hts
    lows = [] # 2d list [[low y, low x], etc..]
    for y, col in enumerate(hts):
        for x, h in enumerate(col):
            # val can't be greater than 9 so this is default
            [up, down, left, right] = [10,10,10,10] 
            # used for adjacent checks
            hasUp       = (y != 0)
            hasDown     = (y != len(hts) - 1)
            hasLeft     = (x != 0) 
            hasRight    = (x != len(col) - 1)

            # get adjacent heights 
            if(hasUp):      up      = hts[y-1][x]
            if(hasDown):    down    = hts[y+1][x]
            if(hasLeft):    left    = hts[y][x-1]
            if(hasRight):   right   = hts[y][x+1]

            # low flag
            isLow = True

            # test if height is lower than all directions or not
            for d in [up, down, left, right]:
                if (h >= d):
                   isLow = False 

            if(isLow): # record coords at each low 
                lows.append([y, x])

    return lows


def determineBasins(hts, lows):
    # internal functions to determine Basins
    def notNine(c): return hts[c[0]][c[1]] != 9
    # the coordinate is within grid of heights
    def inBounds(c):
        return ((c[0] >= 0 and c[1] >= 0) and
        (c[0] <= len(hts) - 1 and c[1] <= len(hts[0]) - 1))

    basins = [] # 2d list [[basin nums],[basin nums],etc..]

    #breakpoint()
    for low in lows:
        d = 'hor' 
        inBasin = [low] # current nums in basin
        addToBasin = [] # nums to be added to basin for next iteration
        # alternate between exploring hor and vert of all identified basin nums
        # keep exploring until nothing left to add
        while True:
            inBasin = inBasin + addToBasin # update in basin
            addToBasin = [] # make sure to clear this

            for c in inBasin:
                # -1 signals seach in direction has stopped
                vertSearch = {'up': 1, 'down': 1} # distance up/down from origin
                horSearch = {'left': 1, 'right': 1}
                dirCount = 4 # how many search directions still active

                # helper dirSearch used for each search direction
                def dirSearch(d, coord): 
                    if(inBounds(coord) and 
                       coord not in addToBasin + inBasin and 
                       notNine(coord)):

                        addToBasin.append(coord)
                        return 0 
                    d = -1
                    return -1

                while(dirCount > 0):

                    # vertical search
                    if(vertSearch['up'] != -1):
                        upPos = c[0] - vertSearch['up'] # y + how far up to search
                        upCoord = [upPos, c[1]]
                        dirCount += dirSearch(vertSearch['up'], upCoord)
                    
                    if(vertSearch['down'] != -1):
                        downPos = c[0] + vertSearch['down']
                        downCoord = [downPos, c[1]]
                        dirCount += dirSearch(vertSearch['down'], downCoord)

                    # horizontal search
                    if(horSearch['left'] != -1):
                        leftPos = c[1] - horSearch['left']
                        leftCoord = [c[0], leftPos]
                        dirCount += dirSearch(horSearch['left'], leftCoord)

                    if(horSearch['right'] != -1):
                        rightPos = c[1] + horSearch['right']
                        rightCoord = [c[0], rightPos]
                        dirCount += dirSearch(horSearch['right'], rightCoord)

            # nothing left to add, break
            if(len(addToBasin) == 0):
                break

        basins.append(inBasin)
    return basins


heights = formatData(data) 
lows = determineLows(heights)
basins = determineBasins(heights, lows)

# calculating/printing solution..

# get sorted list of basin sizes
basinSizes = sorted(list(map(lambda x: len(x), basins)))
total = 1;

for size in (basinSizes[-3:]):
    total *= size 

print(total)
</code></pre></div></div>,
    </body>
</html>
